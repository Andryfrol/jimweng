package main

import (
	"bytes"
	"encoding/json"
	"io/ioutil"
	"net/http"
	"strings"
	"fmt"
)

// claim node : would declare properties that would be writed to neo4j
type nodeInfo struct {
	DomainID  string
	DomainID string
	Name     string
	TAG      string
	Link     string
	Relation string
}

// declare to parse json format while use NewRequest
type Payload struct {
	Query string `json:"query"`
}

func neo4jCreateNodes(c nodeInfo) string {
	var bodyString = "create (" + c.DomainID + ":" + c.TAG + " {domainId:'" + c.DomainID + "', name:'" + c.Name + "'})"
	return bodyString
}

func neo4jLinkString(c nodeInfo) string {
	var linkString string
	if len(strings.Split(c.Link, "|")) == 1 {
		linkString = "create " + c.Link + " = (" + strings.Split(c.Link, "_")[0] + ")-[:" + c.Relation + "]->(" + strings.Split(c.Link, "_")[1] + ")"
	} else {
		linkArray := strings.Split(c.Link, "|")
		linkRelation := strings.Split(c.Relation, "|")
		for i := 0; i < len(linkArray); i++ {
			tempString := "create " + linkArray[i] + " = (" + strings.Split(linkArray[i], "_")[0] + ")-[:" + linkRelation[i] + "]->(" + strings.Split(linkArray[i], "_")[1] + ")"
			linkString = linkString + " " + tempString
		}
	}
	return linkString
}

func CreateNodes(s string) {

	data := Payload{
		Query: s,
	}

	payloadBytes, err := json.Marshal(data)

	if err != nil {
		// handle err
	}
	body := bytes.NewReader(payloadBytes)

	req, err := http.NewRequest("POST", "http://172.31.86.190:7474/db/data/cypher", body)
	if err != nil {
		// handle err
	}

	req.SetBasicAuth("neo4j", "na")
	req.Header.Set("Accept", "application/json")
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		// handle err
	}
	defer resp.Body.Close()
}

func neo4jMainFunc(s string) {

	// define commitArray
	var parseBodyString string
	var parselinkString string
	var checkNodesString = neo4jQueryNodes()
	var mesurementArray = strings.Split(s, "\n")
	// create request body
	for index := 0; index < len(mesurementArray); index++ {
		neededMeasurement := strings.Split(mesurementArray[index], ",")
		if neededMeasurement[0] == "neo4j" {
			fmt.Println("The origin neo4j databases include nodes-relationships",checkNodesString)
			// if there has already exists nodes than do not recreate
			for i := 0; i < (len(neededMeasurement)-1)/6; i++ {
				tempDomainID := strings.Split(neededMeasurement[6*i+3], "=")[1]
				if strings.Contains(checkNodesString,tempDomainID){
					fmt.Println("The duplicate nodes is",tempDomainID)
					continue
				}

				nodesCreated := nodeInfo{
					DomainID:  strings.Split(neededMeasurement[6*i+1], "=")[1],
					TAG:      strings.Split(neededMeasurement[6*i+2], "=")[1],
					DomainID: tempDomainID,
					Name:     strings.Split(neededMeasurement[6*i+4], "=")[1],
					Link:     strings.Split(neededMeasurement[6*i+5], "=")[1],
					Relation: strings.Split(neededMeasurement[6*i+6], "=")[1],
				}

				// neo4jCreateNodes(nodesCreated)

				if !(nodesCreated.Link == "") {
					parselinkString = parselinkString + " " + neo4jLinkString(nodesCreated)
				}
				parseBodyString = parseBodyString + " " + neo4jCreateNodes(nodesCreated)
			}
			parseBodyString = parseBodyString + parselinkString
			CreateNodes(parseBodyString)
		}
	}
}

func main() {
	// assume telegraf.Metric body would be like this
	// neo4j telegraf.Metric would be pass with map[name]field ; e.g. neo4j,DomainID=testDomainID,tag=testTag ,domainID=testDomainID, name=testName,link=testDomainID2_testDomainID3 (rmk: testDomainID2 belong to testDomainID3),relation=belong

	
	var testString = "neo4j,DomainID=testDomainID,tag=testTag,domainID=testDomainID, name=testName,link=testDomainID_testDomainID2|testDomainID3_testDomainID,relation=belong|take,DomainID=testDomainID2,tag=testTag2,domainID=testDomainID2, name=testName2,link=testDomainID2_testDomainID3,relation=follow,DomainID=testDomainID3,tag=testTag3,domainID=testDomainID3, name=testName3,link=testDomainID_testDomainID3,relation=after"


	neo4jMainFunc(testString)
	// getJsonResponse := neo4jQueryNodes().Data
	// fmt.Println(getJsonResponse)
	// fmt.Println(neo4jQueryNodes("query"))

}


// declare a struct to implement json array
type AutoGenerated struct {
	Columns []string        `json:"columns"`
	Data    [][]string `json:"data"`
}

type testMap struct{
	NAME string
	TAG string
	
}



func neo4jQueryNodes() string {

	data := Payload{
		Query: "MATCH p=(testDomainID)-[r]->(testDomainID2) return testDomainID.domainId, type(r), testDomainID2.domainId",
		// Query: "match(n) return n.domainId",
	}
	payloadBytes, err := json.Marshal(data)
	if err != nil {
		// handle err
	}
	body := bytes.NewReader(payloadBytes)

	req, err := http.NewRequest("POST", "http://172.31.86.190:7474/db/data/cypher", body)
	if err != nil {
		// handle err
	}
	req.SetBasicAuth("neo4j", "na")
	req.Header.Set("Accept", "application/json")
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)
	jsonRsponse := AutoGenerated{}
	bodyBytes, _ := ioutil.ReadAll(resp.Body)
	json.Unmarshal(bodyBytes, &jsonRsponse)
	fmt.Println()
	var returnString =""
	if len(jsonRsponse.Data) >= 1 {
		for i := range jsonRsponse.Data {
			// for j := range jsonRsponse.Data
					returnString = returnString + " " +jsonRsponse.Data[i][0]+ "+" +jsonRsponse.Data[i][1]+ "+" +jsonRsponse.Data[i][2]
		}
	}else{
		fmt.Println("length is 0")
	}

	if err != nil {
		// handle err
	}
	defer resp.Body.Close()
	return returnString
}